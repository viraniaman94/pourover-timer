<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Pourover Coffee Timer</title>
    <!-- React and ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root {
        --primary: #6d4c41;
        --secondary: #a1887f;
        --accent: #d7ccc8;
        --background: #efebe9;
        --text: #3e2723;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background-color: var(--background);
        color: var(--text);
        padding: 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: var(--primary);
        text-align: center;
        margin-bottom: 20px;
        font-size: 2rem;
      }

      .timer-display {
        font-size: 3rem;
        text-align: center;
        margin: 20px 0;
        font-weight: bold;
        color: var(--primary);
        font-family: monospace;
      }

      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      button {
        background-color: var(--primary);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: var(--secondary);
      }

      button:disabled {
        background-color: var(--accent);
        cursor: not-allowed;
      }

      .setup-section {
        margin-bottom: 20px;
        padding: 15px;
        background-color: var(--accent);
        border-radius: 8px;
      }

      .input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        align-items: center;
      }

      input {
        padding: 8px;
        border: 1px solid var(--secondary);
        border-radius: 4px;
        font-size: 1rem;
      }

      textarea {
        padding: 8px;
        border: 1px solid var(--secondary);
        border-radius: 4px;
        font-size: 1rem;
        width: 100%;
        min-height: 100px;
        resize: vertical;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      .description-box {
        margin: 15px 0;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        border: 1px solid var(--secondary);
      }

      .description-box h3 {
        margin-bottom: 10px;
        color: var(--primary);
        border-bottom: 1px solid var(--accent);
        padding-bottom: 5px;
      }

      .description-box p {
        line-height: 1.5;
        white-space: pre-wrap;
      }

      label {
        font-weight: bold;
        min-width: 120px;
      }

      .tick-list {
        margin-top: 20px;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid var(--accent);
        border-radius: 4px;
        padding: 10px;
      }

      .tick-item {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        border-bottom: 1px solid var(--accent);
        flex-wrap: wrap;
        gap: 10px;
      }

      .tick-item:last-child {
        border-bottom: none;
      }

      .tick-time {
        font-weight: bold;
        min-width: 60px;
      }

      .tick-description {
        flex-grow: 1;
      }

      .tick-description input {
        width: 100%;
      }

      .delete-btn {
        background-color: #c62828;
        padding: 5px 10px;
        font-size: 0.8rem;
      }

      .edit-btn {
        background-color: #2e7d32;
        padding: 5px 10px;
        font-size: 0.8rem;
        margin-right: 8px; /* Added space between edit and delete buttons */
      }

      .save-btn {
        background-color: #1565c0;
        padding: 5px 10px;
        font-size: 0.8rem;
      }

      .progress-bar {
        height: 10px;
        background-color: var(--accent);
        border-radius: 5px;
        margin: 20px 0;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        height: 100%;
        background-color: var(--primary);
        width: 0%;
        transition: width 0.3s linear;
      }

      .tick-markers {
        position: relative;
        height: 30px;
        margin: 10px 0;
        background-color: var(--accent);
        border-radius: 5px;
      }

      .tick-marker {
        position: absolute;
        width: 2px;
        height: 100%;
        background-color: var(--primary);
        transform: translateX(-50%);
      }

      .current-tick {
        background-color: #c62828;
        width: 4px;
      }

      .current-instruction {
        margin-top: 20px;
        padding: 15px;
        background-color: #e6f7ff;
        border-radius: 8px;
        border-left: 4px solid #1890ff;
        font-size: 1.2rem;
      }

      .current-instruction h3 {
        margin-bottom: 10px;
        color: #1890ff;
      }

      .next-step {
        margin-top: 10px;
        padding: 15px;
        background-color: #fff7e6;
        border-radius: 8px;
        border-left: 4px solid #fa8c16;
      }

      .next-step h3 {
        margin-bottom: 10px;
        color: #fa8c16;
      }

      .preset-buttons {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .clear-btn {
        background-color: #f57c00;
      }

      /* New styles for preset management */
      .preset-section {
        margin-bottom: 15px;
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        border: 1px solid var(--secondary);
      }

      .preset-list {
        max-height: 200px;
        overflow-y: auto;
        margin: 10px 0;
        border: 1px solid var(--accent);
        border-radius: 4px;
      }

      .preset-item {
        display: flex;
        justify-content: space-between;
        padding: 10px;
        border-bottom: 1px solid var(--accent);
        align-items: center;
      }

      .preset-item:last-child {
        border-bottom: none;
      }

      .preset-name {
        font-weight: bold;
        flex-grow: 1;
      }

      .preset-action-buttons {
        display: flex;
        gap: 5px;
      }

      .preset-management {
        margin-top: 15px;
      }

      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .modal {
        background-color: white;
        border-radius: 8px;
        padding: 20px;
        width: 90%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        border-bottom: 1px solid var(--accent);
        padding-bottom: 10px;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--text);
      }

      .modal-content {
        margin-bottom: 15px;
      }

      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 15px;
        border-top: 1px solid var(--accent);
        padding-top: 15px;
      }

      .btn-load {
        background-color: #1976d2;
      }

      .btn-rename {
        background-color: #7b1fa2;
      }

      .rename-input {
        width: 100%;
        margin: 10px 0;
      }

      /* New styles for tick adder box */
      .tick-adder-box {
        background-color: white;
        border-radius: 8px;
        border: 1px solid var(--secondary);
        padding: 15px;
        margin-bottom: 20px;
        position: relative;
      }

      .tick-adder-box h3 {
        color: var(--primary);
        margin-bottom: 10px;
        border-bottom: 1px solid var(--accent);
        padding-bottom: 5px;
      }

      /* Modified: Removed the absolute positioning and added text-align for proper button placement */
      .tick-adder-box .add-button-container {
        margin-top: 10px;
        text-align: right;
      }

      @media (max-width: 600px) {
        .input-group {
          flex-direction: column;
          align-items: flex-start;
        }

        .controls {
          flex-direction: column;
        }

        .timer-display {
          font-size: 2.5rem;
        }

        .tick-item {
          flex-direction: column;
        }

        .preset-item {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
        }

        .preset-action-buttons {
          width: 100%;
          justify-content: space-between;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      function parseTimeInput(input) {
        // Handle different formats: seconds, mm:ss, or decimal minutes
        if (input.includes(':')) {
          const [mins, secs] = input.split(':').map((num) => parseInt(num, 10));
          return mins * 60 + secs;
        } else if (input.includes('.')) {
          // Treat as decimal minutes
          return Math.round(parseFloat(input) * 60);
        } else {
          // Treat as seconds
          return parseInt(input, 10);
        }
      }

      // Modal component for preset operations
      function Modal({ isOpen, onClose, title, children }) {
        if (!isOpen) return null;

        return (
          <div className="modal-overlay" onClick={onClose}>
            <div className="modal" onClick={(e) => e.stopPropagation()}>
              <div className="modal-header">
                <h2>{title}</h2>
                <button className="modal-close" onClick={onClose}>
                  &times;
                </button>
              </div>
              <div className="modal-content">{children}</div>
            </div>
          </div>
        );
      }

      function App() {
        const [totalDuration, setTotalDuration] = useState(180); // 3 minutes default
        const [ticks, setTicks] = useState([0]); // Start with t=0
        const [tickDescriptions, setTickDescriptions] = useState({ 0: 'Start timer' });
        const [isRunning, setIsRunning] = useState(false);
        const [currentTime, setCurrentTime] = useState(0);
        const [newTickTime, setNewTickTime] = useState('');
        const [newTickDescription, setNewTickDescription] = useState('');
        const [lastTickIndex, setLastTickIndex] = useState(-1);
        const [currentInstruction, setCurrentInstruction] = useState('');
        const [nextStep, setNextStep] = useState('');
        const [editingDescription, setEditingDescription] = useState(null);
        const [tempDescription, setTempDescription] = useState('');
        const [presetLoaded, setPresetLoaded] = useState(false);
        const [presetDescription, setPresetDescription] = useState('');
        const [editingPresetDescription, setEditingPresetDescription] = useState(false);
        const [tempPresetDescription, setTempPresetDescription] = useState('');

        // New state for preset management
        const [savedPresets, setSavedPresets] = useState([]);
        const [showSaveModal, setShowSaveModal] = useState(false);
        const [showManageModal, setShowManageModal] = useState(false);
        const [showLoadModal, setShowLoadModal] = useState(false); // New state for load modal
        const [newPresetName, setNewPresetName] = useState('');
        const [renamingPreset, setRenamingPreset] = useState(null);
        const [newPresetNameForRename, setNewPresetNameForRename] = useState('');

        const timerRef = useRef(null);
        const audioRef = useRef(null);

        // Load saved presets from localStorage when component mounts
        useEffect(() => {
          try {
            const storedPresets = localStorage.getItem('coffeeTimerPresets');
            if (storedPresets) {
              setSavedPresets(JSON.parse(storedPresets));
            }
          } catch (error) {
            console.error('Error loading presets from localStorage:', error);
            // If there's an error, we'll just start with an empty array
          }

          // Create audio context for tick sound
          audioRef.current = new (window.AudioContext || window.webkitAudioContext)();

          return () => {
            if (timerRef.current) {
              clearInterval(timerRef.current);
            }
          };
        }, []);

        // Save presets to localStorage whenever they change
        useEffect(() => {
          try {
            localStorage.setItem('coffeeTimerPresets', JSON.stringify(savedPresets));
          } catch (error) {
            console.error('Error saving presets to localStorage:', error);
          }
        }, [savedPresets]);

        useEffect(() => {
          if (isRunning) {
            timerRef.current = setInterval(() => {
              setCurrentTime((prevTime) => {
                const newTime = prevTime + 0.1;

                // Check if we've reached the end
                if (newTime >= totalDuration) {
                  clearInterval(timerRef.current);
                  setIsRunning(false);
                  return totalDuration;
                }

                // Check if we've hit a tick
                const currentTickIndex = ticks.findIndex(
                  (tick) => prevTime < tick && newTime >= tick,
                );

                if (currentTickIndex !== -1) {
                  playTickSound();
                  setLastTickIndex(currentTickIndex);

                  // Set current instruction
                  const tickTime = ticks[currentTickIndex];
                  setCurrentInstruction(
                    tickDescriptions[tickTime] || `Tick at ${formatTime(tickTime)}`,
                  );

                  // Set next step message
                  if (currentTickIndex < ticks.length - 1) {
                    const nextTickTime = ticks[currentTickIndex + 1];
                    const action =
                      tickDescriptions[nextTickTime] || `Tick at ${formatTime(nextTickTime)}`;
                    const timeUntilNext = nextTickTime - tickTime;
                    setNextStep(`In ${timeUntilNext} seconds: ${action}`);
                  } else {
                    setNextStep('Complete! Your timer has finished.');
                  }
                }

                return newTime;
              });
            }, 100); // Update every 100ms for smoother progress
          } else if (timerRef.current) {
            clearInterval(timerRef.current);
          }

          return () => {
            if (timerRef.current) {
              clearInterval(timerRef.current);
            }
          };
        }, [isRunning, totalDuration, ticks, tickDescriptions]);

        const playTickSound = () => {
          const oscillator = audioRef.current.createOscillator();
          const gainNode = audioRef.current.createGain();

          oscillator.type = 'sine';
          oscillator.frequency.value = 800;
          gainNode.gain.value = 0.5;

          oscillator.connect(gainNode);
          gainNode.connect(audioRef.current.destination);

          oscillator.start();

          // Stop after 200ms
          setTimeout(() => {
            oscillator.stop();
          }, 200);
        };

        const handleStart = () => {
          if (currentTime >= totalDuration) {
            // Reset if we're at the end
            setCurrentTime(0);
            setLastTickIndex(-1);
            setCurrentInstruction('');
            setNextStep('');
          }

          // Set initial instruction and next step
          if (currentTime === 0) {
            setCurrentInstruction('Timer started');
            if (ticks.length > 1) {
              const nextTickTime = ticks[1];
              const action =
                tickDescriptions[nextTickTime] || `Tick at ${formatTime(nextTickTime)}`;
              const timeUntilNext = nextTickTime - ticks[0];
              setNextStep(`In ${timeUntilNext} seconds: ${action}`);
            }
          }

          setIsRunning(true);
        };

        const handlePause = () => {
          setIsRunning(false);
        };

        const handleReset = () => {
          setIsRunning(false);
          setCurrentTime(0);
          setLastTickIndex(-1);
          setCurrentInstruction('');
          setNextStep('');
        };

        const handleAddTick = () => {
          if (!newTickTime.trim()) return;

          try {
            const tickSeconds = parseTimeInput(newTickTime);

            if (isNaN(tickSeconds) || tickSeconds < 0 || tickSeconds > totalDuration) {
              alert(`Please enter a valid time between 0 and ${formatTime(totalDuration)}`);
              return;
            }

            // Check if this tick already exists
            if (ticks.includes(tickSeconds)) {
              alert(`A tick at ${formatTime(tickSeconds)} already exists`);
              return;
            }

            // Add tick and sort
            const updatedTicks = [...ticks, tickSeconds].sort((a, b) => a - b);

            // Add description if provided
            const updatedDescriptions = { ...tickDescriptions };
            if (newTickDescription.trim()) {
              updatedDescriptions[tickSeconds] = newTickDescription;
            }

            setTicks(updatedTicks);
            setTickDescriptions(updatedDescriptions);
            setNewTickTime('');
            setNewTickDescription('');
          } catch (error) {
            alert('Invalid time format. Use seconds, mm:ss, or decimal minutes.');
          }
        };

        const handleRemoveTick = (index) => {
          const tickToRemove = ticks[index];
          const updatedTicks = ticks.filter((_, i) => i !== index);

          // Also remove the description
          const updatedDescriptions = { ...tickDescriptions };
          delete updatedDescriptions[tickToRemove];

          setTicks(updatedTicks);
          setTickDescriptions(updatedDescriptions);
        };

        const handleTotalDurationChange = (e) => {
          const input = e.target.value;
          try {
            const durationSeconds = parseTimeInput(input);
            if (!isNaN(durationSeconds) && durationSeconds > 0) {
              setTotalDuration(durationSeconds);
            }
          } catch (error) {
            // Invalid input, don't update
          }
        };

        const handlePresetPulsePourover = () => {
          // New preset for pulse pourover with specific instructions
          const presetTicks = [0, 2, 47, 57, 67, 77, 87, 97, 107, 117];

          // Preset descriptions based on user's requirements
          const presetDescriptions = {
            0: 'Get ready...',
            2: 'Start pouring, and bloom until next tick (wait for 45s, up to 50g water)',
            47: 'Start pouring (10s, up to 100g water total)',
            57: 'Stop pouring',
            67: 'Start pouring (10s, up to 150g water total)',
            77: 'Stop pouring',
            87: 'Start pouring (10s, up to 200g water total)',
            97: 'Stop pouring',
            107: 'Start pouring (10s, up to 250g water total)',
            117: 'Stop pouring and let it draw down',
          };

          // Preset overall description with equipment and dosing details
          const description = `EQUIPMENT:
      - Kettle with >=250g boiling water
      - 15g coffee (medium-fine grind)
      - Filter paper, rinsed with hot water
      - Pre-heated Hario V60

      INSTRUCTIONS:
      This pulse pour technique helps maintain an even extraction by periodically adding water in controlled amounts. Ensure your kettle is filled with enough hot water and all equipment is pre-heated for best results.`;

          setTicks(presetTicks);
          setTickDescriptions(presetDescriptions);
          setPresetDescription(description);
          setTotalDuration(180); // 3 minutes
          setPresetLoaded(true);
        };

        const handlePresetJHUltimateV60 = () => {
          // James Hoffmann's Ultimate V60 technique
          const presetTicks = [0, 45, 75, 105, 108, 115, 120, 210];

          const presetDescriptions = {
            0: 'Add 60g bloom water (2x coffee weight). Swirl until evenly mixed',
            45: 'Add water to reach 300g total (add 240g) over next 30 seconds',
            75: 'Add water to reach 500g total (add 200g) over next 30 seconds',
            105: 'Stir 1x clockwise and 1x anticlockwise with spoon',
            108: 'Allow to drain a little',
            115: 'Give V60 a gentle swirl to flatten the bed',
            120: 'Let brew drawdown (aim to finish by 3:30)',
            210: 'Brew complete! Enjoy your coffee!',
          };

          const description = `THE ULTIMATE V60 TECHNIQUE - JAMES HOFFMANN

      EQUIPMENT NEEDED:
      - V60 dripper with filter paper (rinsed with hot water)
      - 30g coffee (medium-fine grind)
      - 500g water just off boil
      - Timer
      - Scale
      - Spoon for stirring

      BREWING RATIO: 60g/L (30g coffee to 500mL water)
      GRIND: Medium-fine
      WATER TEMPERATURE: As hot as possible (especially for light roasts)

      PRE-BREWING STEPS:
      - Rinse paper filter with water just off boil (removes paper taste and preheats brewer)
      - Add coffee grounds and create a well in the middle
      - Start timer at 0:00

      TECHNIQUE NOTES:
      - Full V60 maintains high temperature
      - Pouring directly onto filter is fine
      - Higher temperature = faster drawdown
      - Filter paper choice affects drawdown time
      - Swirling helps ensure flat coffee bed for even extraction`;

          setTicks(presetTicks);
          setTickDescriptions(presetDescriptions);
          setPresetDescription(description);
          setTotalDuration(240); // 4 minutes
          setPresetLoaded(true);
        };

        const handleClearPreset = () => {
          setTicks([0]);
          setTickDescriptions({ 0: 'Start timer' });
          setPresetDescription('');
          setPresetLoaded(false);
        };

        const startEditDescription = (tick) => {
          setEditingDescription(tick);
          setTempDescription(tickDescriptions[tick] || '');
        };

        const saveDescription = (tick) => {
          const updatedDescriptions = {
            ...tickDescriptions,
            [tick]: tempDescription,
          };
          setTickDescriptions(updatedDescriptions);
          setEditingDescription(null);
        };

        const startEditPresetDescription = () => {
          setEditingPresetDescription(true);
          setTempPresetDescription(presetDescription);
        };

        const savePresetDescription = () => {
          setPresetDescription(tempPresetDescription);
          setEditingPresetDescription(false);
        };

        // New functions for preset management
        const openSavePresetModal = () => {
          setShowSaveModal(true);
          setNewPresetName('My Coffee Recipe');
        };

        const openManagePresetsModal = () => {
          setShowManageModal(true);
          setRenamingPreset(null);
        };

        // New function to open load presets modal
        const openLoadPresetsModal = () => {
          setShowLoadModal(true);
        };

        const handleSavePreset = () => {
          if (!newPresetName.trim()) {
            alert('Please enter a name for your preset');
            return;
          }

          // Check if name already exists
          if (savedPresets.some((preset) => preset.name === newPresetName)) {
            const confirmOverwrite = window.confirm(
              `A preset named "${newPresetName}" already exists. Do you want to overwrite it?`,
            );

            if (confirmOverwrite) {
              // Remove the existing preset with this name
              const filteredPresets = savedPresets.filter((p) => p.name !== newPresetName);

              // Add the new preset
              const newPreset = {
                name: newPresetName,
                ticks,
                tickDescriptions,
                totalDuration,
                description: presetDescription,
              };

              setSavedPresets([...filteredPresets, newPreset]);
            } else {
              // User canceled overwrite
              return;
            }
          } else {
            // Create new preset
            const newPreset = {
              name: newPresetName,
              ticks,
              tickDescriptions,
              totalDuration,
              description: presetDescription,
            };

            setSavedPresets([...savedPresets, newPreset]);
          }

          setShowSaveModal(false);
          alert(`Preset "${newPresetName}" saved successfully!`);
        };

        const handleLoadPreset = (preset) => {
          setTicks(preset.ticks);
          setTickDescriptions(preset.tickDescriptions);
          setTotalDuration(preset.totalDuration);
          setPresetDescription(preset.description || '');
          setPresetLoaded(true);
          setShowLoadModal(false);
        };

        const handleDeletePreset = (presetName) => {
          const confirmDelete = window.confirm(
            `Are you sure you want to delete the preset "${presetName}"?`,
          );

          if (confirmDelete) {
            const updatedPresets = savedPresets.filter((p) => p.name !== presetName);
            setSavedPresets(updatedPresets);
          }
        };

        const startRenamePreset = (preset) => {
          setRenamingPreset(preset.name);
          setNewPresetNameForRename(preset.name);
        };

        const saveRenamedPreset = () => {
          if (!newPresetNameForRename.trim()) {
            alert('Please enter a valid name');
            return;
          }

          // Check if new name already exists (and it's not the same as original)
          if (
            newPresetNameForRename !== renamingPreset &&
            savedPresets.some((p) => p.name === newPresetNameForRename)
          ) {
            alert('A preset with this name already exists. Please choose a different name.');
            return;
          }

          // Update the preset name
          const updatedPresets = savedPresets.map((p) => {
            if (p.name === renamingPreset) {
              return { ...p, name: newPresetNameForRename };
            }
            return p;
          });

          setSavedPresets(updatedPresets);
          setRenamingPreset(null);
        };

        return (
          <div className="container">
            <h1>Pourover Coffee Timer</h1>

            <div className="setup-section">
              <div className="preset-buttons">
                <button onClick={handlePresetPulsePourover} disabled={isRunning || presetLoaded}>
                  Load JH One Cup V60 Preset
                </button>
                <button onClick={handlePresetJHUltimateV60} disabled={isRunning || presetLoaded}>
                  Load JH Ultimate V60 Preset
                </button>
                <button onClick={openLoadPresetsModal} disabled={isRunning}>
                  Load Saved Recipe
                </button>
                <button onClick={openSavePresetModal} disabled={isRunning}>
                  Save Recipe as Preset
                </button>
                <button onClick={openManagePresetsModal} disabled={isRunning}>
                  Manage Presets
                </button>
                {presetLoaded && (
                  <button className="clear-btn" onClick={handleClearPreset} disabled={isRunning}>
                    Clear Preset
                  </button>
                )}
              </div>

              <div className="input-group">
                <label htmlFor="duration">Total Duration:</label>
                <input
                  id="duration"
                  type="text"
                  value={formatTime(totalDuration)}
                  onChange={handleTotalDurationChange}
                  disabled={isRunning}
                />
              </div>

              {/* Recipe details moved up */}
              {presetDescription && (
                <div className="description-box">
                  <h3>Preparation Details</h3>
                  {editingPresetDescription ? (
                    <>
                      <textarea
                        value={tempPresetDescription}
                        onChange={(e) => setTempPresetDescription(e.target.value)}
                        disabled={isRunning}
                      />
                      <button
                        className="save-btn"
                        onClick={savePresetDescription}
                        disabled={isRunning}
                        style={{ marginTop: '10px' }}
                      >
                        Save Description
                      </button>
                    </>
                  ) : (
                    <>
                      <p>{presetDescription}</p>
                      <button
                        className="edit-btn"
                        onClick={startEditPresetDescription}
                        disabled={isRunning}
                        style={{ marginTop: '10px' }}
                      >
                        Edit Description
                      </button>
                    </>
                  )}
                </div>
              )}

              {!presetDescription && !presetLoaded && (
                <div className="description-box">
                  <h3>Recipe Details (Optional)</h3>
                  {editingPresetDescription ? (
                    <>
                      <textarea
                        value={tempPresetDescription}
                        onChange={(e) => setTempPresetDescription(e.target.value)}
                        placeholder="Add equipment details, coffee dosage, and other preparation notes here."
                        disabled={isRunning}
                      />
                      <button
                        className="save-btn"
                        onClick={savePresetDescription}
                        disabled={isRunning}
                        style={{ marginTop: '10px' }}
                      >
                        Save Description
                      </button>
                    </>
                  ) : (
                    <>
                      {presetDescription ? (
                        <p>{presetDescription}</p>
                      ) : (
                        <p style={{ color: '#999' }}>
                          No recipe details added. Click Edit Description to ad No recipe details
                          added. Click Edit Description to add equipment and dosing information.
                        </p>
                      )}
                      <button
                        className="edit-btn"
                        onClick={startEditPresetDescription}
                        disabled={isRunning}
                        style={{ marginTop: '10px' }}
                      >
                        Edit Description
                      </button>
                    </>
                  )}
                </div>
              )}

              {/* Tick adder in a visually separate box */}
              <div className="tick-adder-box">
                <h3>Add New Tick Point</h3>
                <div className="input-group">
                  <label htmlFor="new-tick">Tick At:</label>
                  <input
                    id="new-tick"
                    type="text"
                    value={newTickTime}
                    onChange={(e) => setNewTickTime(e.target.value)}
                    placeholder="Time (e.g., 45, 1:30, 1.5)"
                    disabled={isRunning}
                  />
                </div>

                <div className="input-group">
                  <label htmlFor="new-tick-description">Description:</label>
                  <input
                    id="new-tick-description"
                    type="text"
                    value={newTickDescription}
                    onChange={(e) => setNewTickDescription(e.target.value)}
                    placeholder="What to do at this tick"
                    disabled={isRunning}
                    style={{ width: '100%' }}
                  />
                </div>

                {/* Changed: Added a container div and moved the button below the inputs */}
                <div className="add-button-container">
                  <button onClick={handleAddTick} disabled={isRunning} className="add-button">
                    Add
                  </button>
                </div>
              </div>

              <div className="tick-list">
                <h3>Tick Points:</h3>
                {ticks.map((tick, index) => (
                  <div key={tick} className="tick-item">
                    <div className="tick-time">{formatTime(tick)}</div>
                    <div className="tick-description">
                      {editingDescription === tick ? (
                        <input
                          type="text"
                          value={tempDescription}
                          onChange={(e) => setTempDescription(e.target.value)}
                          placeholder="Enter description"
                        />
                      ) : (
                        <span>{tickDescriptions[tick] || 'No description'}</span>
                      )}
                    </div>
                    <div className="tick-actions">
                      {editingDescription === tick ? (
                        <button className="save-btn" onClick={() => saveDescription(tick)}>
                          Save
                        </button>
                      ) : (
                        <button
                          className="edit-btn"
                          onClick={() => startEditDescription(tick)}
                          disabled={isRunning}
                        >
                          Edit
                        </button>
                      )}
                      <button
                        className="delete-btn"
                        onClick={() => handleRemoveTick(index)}
                        disabled={isRunning || index === 0} // Don't allow removing t=0
                      >
                        Remove
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="timer-display">{formatTime(currentTime)}</div>

            <div className="progress-bar">
              <div
                className="progress-fill"
                style={{ width: `${(currentTime / totalDuration) * 100}%` }}
              ></div>
            </div>

            <div className="tick-markers">
              {ticks.map((tick, index) => (
                <div
                  key={tick}
                  className={`tick-marker ${index === lastTickIndex ? 'current-tick' : ''}`}
                  style={{ left: `${(tick / totalDuration) * 100}%` }}
                  title={`${formatTime(tick)} - ${tickDescriptions[tick] || 'No description'}`}
                ></div>
              ))}
            </div>

            {currentInstruction && (
              <div className="current-instruction">
                <h3>Current Action:</h3>
                <p>{currentInstruction}</p>
              </div>
            )}

            {nextStep && (
              <div className="next-step">
                <h3>Next Step:</h3>
                <p>{nextStep}</p>
              </div>
            )}

            <div className="controls">
              <button onClick={handleStart} disabled={isRunning}>
                {currentTime > 0 && currentTime < totalDuration ? 'Resume' : 'Start'}
              </button>
              <button onClick={handlePause} disabled={!isRunning}>
                Pause
              </button>
              <button onClick={handleReset}>Reset</button>
            </div>

            {/* Save Preset Modal */}
            <Modal
              isOpen={showSaveModal}
              onClose={() => setShowSaveModal(false)}
              title="Save Current Recipe as Preset"
            >
              <div>
                <label htmlFor="preset-name">Preset Name:</label>
                <input
                  id="preset-name"
                  type="text"
                  className="rename-input"
                  value={newPresetName}
                  onChange={(e) => setNewPresetName(e.target.value)}
                  placeholder="Enter a name for your preset"
                />
                <p style={{ marginTop: '10px' }}>
                  This will save your current timer configuration including all tick points,
                  descriptions, and recipe details for future use.
                </p>
                <div className="modal-footer">
                  <button onClick={() => setShowSaveModal(false)}>Cancel</button>
                  <button className="save-btn" onClick={handleSavePreset}>
                    Save Preset
                  </button>
                </div>
              </div>
            </Modal>

            {/* Load Presets Modal */}
            <Modal
              isOpen={showLoadModal}
              onClose={() => setShowLoadModal(false)}
              title="Load Saved Recipe"
            >
              <div>
                {savedPresets.length === 0 ? (
                  <p>
                    You don't have any saved presets yet. Create a timer setup and save it as a
                    preset.
                  </p>
                ) : (
                  <div className="preset-list">
                    {savedPresets.map((preset) => (
                      <div key={preset.name} className="preset-item">
                        <div className="preset-name">{preset.name}</div>
                        <div className="preset-action-buttons">
                          <button className="btn-load" onClick={() => handleLoadPreset(preset)}>
                            Load
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
                <div className="modal-footer">
                  <button onClick={() => setShowLoadModal(false)}>Close</button>
                </div>
              </div>
            </Modal>

            {/* Manage Presets Modal */}
            <Modal
              isOpen={showManageModal}
              onClose={() => {
                setShowManageModal(false);
                setRenamingPreset(null);
              }}
              title="Manage Saved Presets"
            >
              <div>
                {savedPresets.length === 0 ? (
                  <p>
                    You don't have any saved presets yet. Create a timer setup and save it as a
                    preset.
                  </p>
                ) : (
                  <div className="preset-list">
                    {savedPresets.map((preset) => (
                      <div key={preset.name} className="preset-item">
                        <div className="preset-name">
                          {renamingPreset === preset.name ? (
                            <input
                              type="text"
                              value={newPresetNameForRename}
                              onChange={(e) => setNewPresetNameForRename(e.target.value)}
                              className="rename-input"
                            />
                          ) : (
                            preset.name
                          )}
                        </div>
                        <div className="preset-action-buttons">
                          {renamingPreset === preset.name ? (
                            <>
                              <button className="save-btn" onClick={saveRenamedPreset}>
                                Save
                              </button>
                              <button onClick={() => setRenamingPreset(null)}>Cancel</button>
                            </>
                          ) : (
                            <>
                              <button
                                className="btn-rename"
                                onClick={() => startRenamePreset(preset)}
                              >
                                Rename
                              </button>
                              <button
                                className="delete-btn"
                                onClick={() => handleDeletePreset(preset.name)}
                              >
                                Delete
                              </button>
                            </>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
                <div className="modal-footer">
                  <button
                    onClick={() => {
                      setShowManageModal(false);
                      setRenamingPreset(null);
                    }}
                  >
                    Close
                  </button>
                </div>
              </div>
            </Modal>
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>
